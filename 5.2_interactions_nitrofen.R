# Модель со взаимодействием на примере данных о токсичности нитрофена

## Токсичность нитрофена

Нитрофен --- гербицид, тератоген, мутаген. Сейчас он не используется в США (первый пестицид, использование которого было запрещено из-за тератогенных эффектов), но все еще используется в России. Эти данные --- данные эксперимента по оценке токсичности нитрофена на дафниях _Ceriodaphnia dubia_ (Bailer, Oris 1994).

50 дафний случайно разделили на 5 групп, посадили в емкости с разной концентрацией нитрофена, оценили число яиц трех последовательных генераций.

- `conc` --- концентрация нитрофена
- `total` --- суммарный размер потомства
- `brood` --- номер выводка
- `N` --- размер потомства в выводке

```{r}
library(readxl)
nit <- read_excel("data/nitrofen.xlsx", sheet = 1)
head(nit)
```

## Задание

- Исследуйте данные о токсичноси нитрофена
- Чтобы выяснить, как численность потомства дафний зависит от концентрации нитрофена в каждом из трех выводков, подберите модель со взаимодействием дискретного и непрерывного предикторов
- Проверьте условия применимости этой модели
- Упростите модель, если это возможно
- Напишите общее уравнение и отдельные уравнения модели для трех выводков
- Постройте график предсказаний модели

## Решение

```{r}
str(nit)
colSums(is.na(nit))
table(nit$conc, nit$brood)
```

## Решение

```{r}
ggplot(nit, aes(x = total, y = 1:nrow(nit))) + geom_point()
ggplot(nit, aes(x = N, y = 1:nrow(nit))) + geom_point()
```

## Решение

### Проверка на колинеарность

```{r}
N1 <- lm(N ~ conc + brood, data = nit)
vif(N1)
```

>- Колинеарности нет

## Решение

### Проверка на гомогенность углов наклона

Подберем полную модель. Попробуем для начала не учитывать общую плодовитость `total` (хоть это и не правильно)

```{r}
N2 <- lm(N ~ conc * brood, data = nit)
drop1(N2, test = "F")
```

>- От исключения взаимодействия модель становится значительно хуже. Оставляем. Это не ANCOVA

## Решение

### Анализ остатков

```{r}
set.seed(234)
cook_cutoff <- 4 / (nrow(nit) - length(coef(N2) - 2))
op <- par(mfrow = c(1, 3)) # располагаем картинки в 3 колонки
plot(N1, which = 4, cook.levels = cook_cutoff)  # Расстояние Кука
residualPlot(N1)        # График остатков
qqPlot(N1)              # Квантильный график остатков
par(op)
```

## Решение

### Заготовка графика остатков в ggplot


```{r}
N2_diag <- data.frame(nit, .fitted = fitted(N2), .resid = resid(N2))
gg_res <- ggplot(N2_diag, aes(x = .fitted, y = .resid)) +
  geom_point() + geom_smooth(method = "loess") +
  geom_hline(yintercept = 0)
gg_res
```

## Решение

### Графики остатков от предикторов в модели

```{r}
gg_res %+% aes(x = conc)
gg_res %+% aes(x = brood) + geom_boxplot()
```

## Решение

### Графики остатков от предикторов не в модели


```{r}
gg_res %+% aes(x = total)
```

## Решение

### Резюме 1 этапа

## Решение
### Подбираем модель с учетом общей плодовитости

```{r}
N3 <- lm(N ~ conc + brood + total + brood:conc, data = nit)
drop1(N3, test = "F")


```

>- От исключения взаимодействия модель становится значительно хуже. Оставляем. Это не ANCOVA

## Решение

### Анализ остатков

```{r}
set.seed(234)
cook_cutoff <- 4 / (nrow(nit) - length(coef(N2) - 2))
op <- par(mfrow = c(1, 3)) # располагаем картинки в 3 колонки
plot(N1, which = 4, cook.levels = cook_cutoff)  # Расстояние Кука
residualPlot(N1)        # График остатков
qqPlot(N1)              # Квантильный график остатков
par(op)
```

## Решение

### Заготовка графика остатков в ggplot


```{r}
N2_diag <- data.frame(nit, .fitted = fitted(N2), .resid = resid(N2))
gg_res <- ggplot(N2_diag, aes(x = .fitted, y = .resid)) +
  geom_point() + geom_smooth(method = "loess") +
  geom_hline(yintercept = 0)
gg_res
```

## Решение

### Графики остатков от предикторов в модели

```{r}
gg_res %+% aes(x = conc)
gg_res %+% aes(x = brood) + geom_boxplot()
```

## Решение

### Графики остатков от предикторов не в модели


```{r}
gg_res %+% aes(x = total)
```

## Решение

### Резюме 2 этапа
