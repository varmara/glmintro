---
title: "Множественные сравнения"
author: "Юта Тамберг, Марина Варфоломеева"
subtitle: ""
output:
  ioslides_presentation:
    css: assets/my_styles.css
    widescreen: yes
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE}
# output options
options(width = 70, scipen = 6, digits = 3)
library(knitr)
library(ggplot2)
library(gridExtra)
library(readxl)
# chunk default options
opts_chunk$set(fig.align='center', tidy = FALSE, fig.width = 7, fig.height = 3, warning = FALSE)
```

# Типы данных

## 1. Мерные = интервальные данные

### 1.1. Непрерывные 

Например температура чая в чашке, рост человека, скорость самолета. Все эти переменные не лимитированы какими-то фиксированными вариантами и могут принимать любые значения.

Любые два показателя температуры или расстояния представляют собой интервал, куда «умещается» бесконечное множество других показателей. 

Чем более точные измерительные инструменты мы используем - более точные данные получаем. Правда следует помнить, что в любом случае это приближение. 

### 1.2. Дискретные 

Эти переменные по природе могут принимать только фиксированные значения: число студентов на занятии, количество яиц в кладке, микроскопов в шкафу или окон в аудитории.

Никакими более точными инструментами мы не подсчитаем студентов точнее, чем до 1 целой.

Шаг между двумя соседними значениям равен для всех пар: разница, или расстояние, между 3 и 4 см равно расстоянию между 7 и 8 см, а шаг между 1 и 2 окнами такой же как между 5 и 6 окнами - один объект.

## 2. Ранжированные

Ранжированные данные устроены иначе. Можно думать о них как о непрерывных, но с потерей информации.

Представьте ученого который готовил растворы разной концентрации чтобы затем измерить их прозрачность и у него сломался рефрактометр. Чтобы не потерять всю работу, он может расположить банки с раствором например по мере уменьшения прозрачности и придать им номера - ранги - с которыми и работать дальше.

Шаг между любыми двумя соседними ранжированными величинами не обязательно одинаковый. Так обычно устроены оценки на экзамене.

## 3. Категориальные = номинальные

Эти переменные называют некие свойства объектов: черный, белый, самец, самка, с хвостом, без радулы.

Сами по себе они очень слабо поддаются обработке, во многом потому что не являютя и с большим трудом переводятся в числа.

Сами по себе в биостатистике они не играют особой роли. Но если посчитать частоту встречаемости, то получатся cчетные данные. 

Из всех мышей в лаборатории 14 серые и 82 белые, в аквариуме 3 самца и 9 самок и т.п. 

## 4. Бинарные

Особый случай как номинальных, так и шкальных данных — бинарные данные, которые проще всего передать числами 0 и 1.

Например, ответы «да» и «нет» на вопросы анкеты, или наличие/отсутствие признака.

Бинарные данные можно представить в виде «логического вектора», то есть набора значений TRUE или FALSE.

Самая главная польза от бинарных данных в том, что в них можно перекодировать практически все остальные типы данных (хотя иногда при этом будет потеряна часть информации). После этого к ним можно применять специальные методы анализа.

# Инструменты

## RStudio

Это графическая оболочка, придуманная для того, чтобы сделать общение с R более удобным. 

По умолчанию RStudio предлагает интерфейс из четырех окон:

- Source. Это простой текстовый редактор, где открывается один или несколько файлов для работы со скриптами.

- Console - командная строка, где "живет" R.
В консоль отправляются на выполнение команды, здесь же R выводит результаты и пишет сообщения об ошибках.

- Environment и History.

- File, Plots, Help и другие.

## RStudio

Я предлагаю на время курса всем настроить расположение окон одинаково: 

| Source        | Console |
|:-------------:|:-------:|
| Environment   | Plots   |

Сделать это можно войдя в меню Tools -> Global Options -> Pane layout

## Полезные клавиатурные сокращения в RStudio

- `Ctrl + Shift + C` - закомментировать/раскомментировать выделенный фрагмент кода

- `Ctrl + Enter` - отправить строку из текстового редактора в консоль. Если выделить несколько строк, то будет выполнен весь фрагмент кода.

- `Tab` или `Ctrl + Space` - посмотреть список автоподстановки. Нажмите после того как начали набирать название функции или переменной, и увидите варианты подсказки. Это помогает печатать код быстро и с меньшим количеством ошибок.

## Как получить помощь

1. В RStudio можно поставить курсор на название функции, например `setwd`, и нажать `F1`
2. Перед названием функции можно напечатать знак вопроса и выполнить эту строку `?setwd`
3. Можно воспользоваться функцией `help()`

```{r eval=FALSE}
help("help")
```

## Собственно R

Все что вы хотите чтобы R для вас сделал, нужно объяснять ему в виде команд. Если неясно, какая команда нужна для определенной операции, придется читать справочники.

Вам придется запомнить достаточно большое количество команд, готовьтесь. 
И как любой язык, R требует знания синтаксиса.

Сложности в работе обязательно будут, но не следует их бояться!

## Начало работы

R работает по принципу вопрос-ответ. Запущенная, программа ничего не делает и ожидает от вас команды. Вы набираете ее и отправляете в консоль. R что-то делает, выводит на экран результат, и переходит в режим ожидания следующей команды.

Значок `>` говорит, что программа готова принимать команды.

Еще вы можете столкнуться со значком `+`. Он значит, что во введенной команде чего-то не хватает, и R ожидает продолжения. Один из самых частых случаев -- потерялась закрывающая скобка.

## Начало работы

Комментарии в тексте R-скрипта обозначаются символом '#'

```{r}
# это комментарии, они не будут выполняться
```

## R как калькулятор, математические операции

```{r}
2 + 2
1024 / 2
34 * 4
2 ^ 4
sqrt(27)
```

## R как калькулятор, математические операции

Многоуровневые конструкции:

```{r}
(10*(3-1))^-1
```

Ответ программы находится на следующей строчке после команды. Здесь он начинается с [1]. Это значит, что программа рассчитала единственное значение.

## Переменные

Оператор присваивания это символ стрелочки `<-`. Он работает справа налево:

`куда_записывать <- что_записывать`

Переменные - это такие контейнеры, в которые можно положить разные данные (начиная с одного-единственного значения) и даже функции. 

### Как давать имена?

- Можно использовать только латинские буквы, цифры, нижнее подчеркивание и точку.

- Имена не должны содержать пробелов, начинаться с точки или цифры.

- R чувствителен к регистру, X и x — это разные имена

## Переменные

Нельзя давать объектам короткие, особенно однобуквенные, имена. Они могут быть уже заняты какой-то функцией, да и вы сами легко запутаетесь в таких переменных. Создавайте понятные и "говорящие" имена.

```{r purl=FALSE, echo=FALSE}
Варианты_названий <- c("a, 1_х, wing color", "var1, var_1", "shelllength", "shell_length, sp.count")
Качество <- c("плохо или недопустимо", "так себе, но допустимо", "хорошо, но трудно читать", "хорошо: информативно, легко читать")
kable(data.frame(Варианты_названий,Качество))
```

## Переменные

Создадим переменную `var_1` и присвоим ей значение `1000`:

```{r }
var_1 <- 1000
```

Чтобы увидеть содержимое переменной, достаточно позвать ее по имени:

```{r}
var_1
```

И использовать в дальнейших рассчетах

```{r}
var_2 <- var_1^(1/3)
```

```{r}
(var_1 + 600) / var_2
```

## Способы создания векторов

Все переменные, что мы сейчас создали, представляют собой векторы одиночной длины.

C единственным значением бывает важно работать, но обычно данных у нас гораздо больше.

- Вектор можно сделать из нескольких значений вручную. Для этого есть команда `с()` от английского concatentate - собрать, склеить. Отдельные значения разделяются запятыми:

```{r}
c(-2.5, 1, 40, 2, 3, 5, 31)
```

- Команда `rep` повторяет одно и то же значение сколько угодно раз

```{r}
rep(-19, 4)
```

## Способы создания векторов

- Команда `seq` нужна для создания векторов, где значения следуют одно за другим без пропусков

```{r}
seq(1:10) # от одного до 10
```

Почитайте хелп и создайте вектор чисел от -5 до 3 и с шагом 0.5

## Pешение

Функция принимает аргументы в таком порядке: `seq(от, до, шаг)`

```{r}
seq(-5, 3, 0.5)
```

## Способы создания векторов

Можно стоить **многоуровневые конструкции**

```{r}
c(-9.3, 0, 2.17, rep(11, 3), -2, seq(51, 55, 2))
```

Векторы можно хранить в переменных для последующего использования

```{r}
vect_num_1 <- -11:12 
```


## Адресация внутри векторов

При помощи оператора `[]`, можно обратится к некоторым элементам вектора. 
В квадратных скобках вам нужно указать один или несколько порядковых номеров элементов

```{r}
vect_num_1[1] # первый элемент в векторе vect_num
vect_num_1[10] # 10-й элемент
vect_num_1[22]
```

## Адресация внутри векторов

Если нам нужно несколько элементов, то их нужно передать квадратным скобкам в виде вектора. Например, элементы с 3 по 5:

```{r}
vect_num_1[3:5]
```

Другой способ - задать вектор с номерами элементов при помощи функции `c()`

```{r}
vect_num_1[c(2, 4, 6)] # возвращает 2-й, 4-й и 6-й элементы
vect_num_1[c(1, 10, 20)] # возвращает 1-й, 10-й и 20-й элементы
```

## Адресация внутри векторов

Но R выдаст ошибку, если при обращении к вектору вы просто перечислили номера элементов через запятую:

```{r eval=FALSE}
vect_num_1[1, 3, 5] # ошибка
vect_num_1[15, 9, 1] # ошибка
```
```{r}
vect_num_1[c(15, 9, 1)] # правильно
```


Очень легко добавить в вектор значение, или объединить векторы. При этом не обязательно создавать новую переменную, можно и перезаписать старую

```{r}
vect_num_2 <- c(vect_num_1, 0, seq(6, 8, 0.5))
vect_num_1 <- c(vect_num_1, 100)
```

## Операции в векторами

Узнаем количество значений:

```{r}
length(vect_num_1)
```

Сумма всех элементов вектора

```{r}
sum(vect_num_1)
```

Сумма разных векторов

```{r}
sum(vect_num_1, vect_num_2)
```

## Операции в векторами

Математические операции

```{r}
vect_num_1 + 2
vect_num_1 * 2
vect_num_1 ^2
```

## Другие типы данных в R

Кроме числовых, бывают и другие типы данных:

### Текстовые данные

Каждый текстовый элемент (string) должен быть окружен кавычками - двойными или одинарными

```{r}
"это текст"
'это тоже текст'
```

Текстовые значения можно объединять:

```{r}
season<-c("winter","spring","winter","winter","spring",
          "spring","summer","summer","summer")
```

## Другие типы данных в R

### Логические данные

```{r}
TRUE # истина
FALSE # ложь
```

Можно сокращать:

```{r}
summer <- c(F, F, F, F, F, F, T, T, T)
summer
```

## Как узнать тип данных в переменной?

Чтобы узнать, что за данные хранятся в переменной, используйте функцию `class()` и `str()`

```{r}
class(vect_num_1)
str(vect_num_1)
class(season)
str(summer)
```

## Пропущенные значения

Не существует ни идельных наблюдений, ни идеальных экспериментов. Чем больше массив данных, тем больше вероятность встретить пропущенные данные. Они бывают нескольких типов.

**Unknown**, неизвестное значение. Измерение было не получено, не записано, или потеряно. Скажем, мы измеряли температуру чая в 20 чашках, отвернулись на минуту, и проходящий мимо коллега унес и выпил одну из них.

**Not applicable**, неприменимое значение. Мы обнаружили нечто, логически несовместимое с признаком, который надо фиксировать. Скажем, мы измеряли длины клюва у обитателей скворечников, и в одном нашли белку.

И тот и другой варианты отличается по смыслу от нуля.

Возьмем пример с чашками чая. Ноль в качестве значения для нашей выпитой чашки будет означать, буквально, что в ней находился тающий снег. Это неверно отражает ситуацию, да еще и исковеркает нам последующий анализ.

## Пропущенные значения

Обойтись без пропущенных данных практически невозможно, поэтому важно выделять места для потерянных значений.

Универсальная форма записи для пропущенного значения это **NA** т.е. Not Available. Вставим NA в какой-нибудь вектор

```{r}
vector1 <- rep(1, 5)
vector2 <- c(NA, rep(1, 5))
```

Посмотреть, какие значения в векторе неопределены можно командой

```{r}
is.na(vector1)
is.na(vector2)
```

## Пропущенные значения

Многие команды, при работе с пропущенными значениями, будут выводить результат NA:

```{r}
sum(vector2)
```

Чтобы узнать, почему и как это исправить - посмотрите в `help("sum")`. 
Выяснится, что у функции `sum()` есть аргумент `na.rm`, который по умолчанию принимает значение `FALSE`, то есть `NA` не учитываются при подсчете суммы.

Если мы передадим функции `sum` аргумент `na.rm = TRUE`, то получится правильная сумма

```{r}
sum(vector2, na.rm = TRUE)
```

## Работа с внешними данными

Работа в RStudio предполагает два сорта внешних источников: текстовые файлы со скриптами (например 1.1_intro_to_R_code.R который у вас сейчас открыт) и файлы с данными.

И те и другие нужно держать внутри той же директории что и запущенный R. Или точнее сказать - следует запускать R из той же директории где находятся файлы с источниками. 

В R очень легко идти по дереву каталогов вниз, но не вверх. То есть внутри рабочей директории со скриптом можно иметь отдельную папку с таблицей данных - ее мы откроем без труда. 

Такой способ организации пространства - де-факто стандарт в работе. Не стоит его менять.

## Устанавливаем рабочую директорию

Проверим, где мы сейчас находимся

```{r}
getwd()
```

Допустим, это не та папка, которая нужна.

Под Linux`ом можно прописать путь целиком:

`setwd("/home/shade/Documents/WORK/2017_field_data/Baltic_Sea")`

Но есть способ проще:
 
Выберите в меню `Session -> Set working Directory... -> To Source File Location`


## Импорт данных

Два самых популярных типа файлов для импорта данных в R это .cvs и .xls

Как организовать свои данные чтобы избежать мучительных переделываний и исправлений?

- никаких пустых ячеек! 

- никаких русских букв

- равное количество значений во всех строках

- в идеале должно быть всего две колонки: значение признака и результат измерения

- правила для названий переменных те же что в R. Главное - никаких пробелов

- десятичная часть отделена точкой а не запятой


## Импорт данных: csv

Формат csv черезвычайно хорош, поскольку в Excel или OpenOffice откроется как привычная глазу таблица. В то же время, это просто особым образом размеченный текстовый файл. Его можно и открыть в блокноте, и с легкостью загрузить в R.

Так как это по сути текст, клеточки таблицы передаются с помощью разделителей. Самые распространенные варианты: табуляция, точка с запятой, это хорошие варианты, а так же запятая и пробел - плохие.

Если будете создавать csv файлы, старайтесь использовать один из хороших вариантов.

После того как данные внесены и отформатированы, в R их загружает команда `read.table("имя файла", sep=";", header=T)`

Первый аргумент - имя файла, оно указывается в кавычках

`sep` указывает разделитель. По умолчанию это пробел или табуляция, но можно записать и другое значение

Аргумент `header` определяет судьбу названий столбцов. По умолчанию его значение FALSE. Чтобы названия были прочитаны и стали именами переменных, нужно указать TRUE.

## Импорт данных: csv

Прочитаем файл с температурами "1.2_temperature.csv" находящийся в папке "data". Это вымышленные данные о температуре и типе напитков, обнаруженных нами в чашках наших коллег в течение года.

```{r}
TEMP <- read.table("data/1.2_temperature.csv", header=T)
```

Посмотрим на несколько начальных строк:

```{r}
head(TEMP)
```

Как видим, все три переменные и их названия на месте.

## Индексация таблицы данных

Для дальнейшей работы с таблицей данных нам пригодятся три команды: две для индексации и одна - для извлечения фрагментов массива данных.

### Значок доллара `$`

`где_искать$что_искать` т.е. `название_массива$название_переменной`


```{r}
TEMP$season
```

## Индексация таблицы данных

### Квадратные скобки `x[i]`

`x` - имя массива где проводится поиск, 
`i` - что собственно мы ищем. 

Чтобы получить все значения переменной, укажем ее номер:

```{r}
TEMP[1]
```

## Индексация таблицы данных

Чтобы найти все значения переменной, отвечающие какому-то условию, мы должны создать двухуровневую конструкцию. Например, нас интересует температура напитков весной.

Сначала сконструируем х: обратимся к переменной `TEMP$temperature`

Затем i: обратимся к переменной `TEMP$season` и укажем, что нас интересуют значения `TEMP$season == "spring"`

Собираем:

```{r}
TEMP$temperature[TEMP$season == "spring"]
```

## Фрагмент таблицы данных

Аналогичную операцию можно проделать с помощью команды 'subset'. Отличие же заключается в том, что вместо вектора значений одной переменной, мы получаем маленький, но настоящий, массив данных.

Попробуйте сами получить фрагмент таблицы, включающий все данные относящиеся к кофе.

## Решение

```{r purl=FALSE}
subset(TEMP, drink == "coffee")
```

# Напоследок

## Установка пакетов

Пакеты в R устанавливать очень просто - при условии что вы занете как они называются. Набираем команду:

`install.packages("имя_пакета")`

Установка происходит раз и навсегда. Но не каждый раз нам нужен именно этот пакет. Поэтому по умолчанию они не загружаются. 

Чтобы использовать пакет в текущей сессии, загружаем его из библиотеки:

`library(имя_пакета)`

При установке название пакета должно быть в кавычках, при загрузке - без кавычек.


## Завершение работы

Ну и наконец, как завершить работу? Это делается командой 

`q()`

Чтобы сохранить workspace текущей сессии, можно использовать аргумент "yes"

`q("yes")`

Можно и просто закрыть RStudio, правда R все равно спросит вас, сохранять ли текущую сессию.
